rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Function to check if the authenticated user has an 'Admin' role.
    function is_admin() {
      return request.auth != null && get(/databases/$(database)/documents/users_data/$(request.auth.uid)).data.role == 'Admin';
    }

    // Helper function to check if the request is from an authenticated user.
    function is_authenticated() {
      return request.auth != null;
    }

    // Helper function to get the expected index ID for price books
    // This function now expects 'normalizedName' and 'normalizedCurrency' fields
    // to be present in the data, as they are pre-processed client-side.
    function getPriceBookIndexId(normalizedName, normalizedCurrency) {
      return normalizedName + '_' + normalizedCurrency;
    }

    // Helper function to validate an incoming timestamp-like object from request.resource.data
    function isValidTimestampObject(data) {
      return data is map &&
             data.keys().hasAll(['seconds', 'nanoseconds']) &&
             data.seconds is number &&
             data.nanoseconds is number;
    }

    // --- 1. Rules for the 'users_data' collection: ---
    match /users_data/{userId} {
      allow read: if is_authenticated() && (request.auth.uid == userId || is_admin());
      allow create: if is_authenticated() &&
                        request.auth.uid == userId &&
                        request.resource.data.keys().hasAll(['displayName', 'email', 'role', 'createdAt', 'lastLogin']) &&
                        request.resource.data.keys().hasOnly(['displayName', 'email', 'role', 'createdAt', 'lastLogin']) &&
                        request.resource.data.email == request.auth.token.email &&
                        request.resource.data.role == 'Standard' &&
                        request.resource.data.createdAt is timestamp &&
                        request.resource.data.lastLogin is timestamp &&
                        request.resource.data.createdAt <= request.time;
      allow update: if is_authenticated() && (request.auth.uid == userId || is_admin()) &&
                        request.resource.data.createdAt == resource.data.createdAt &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.lastLogin is timestamp &&
                        (is_admin() || (request.resource.data.role == resource.data.role));
      allow delete: if false;
    }

    // --- 2. Rules for 'customers' collection: ---
    match /customers/{customerId} {
      allow read: if is_authenticated();
      function is_customer_owner() {
        return resource.data.creatorId == request.auth.uid;
      }
      allow create: if is_authenticated() &&
                        request.resource.data.creatorId == request.auth.uid &&
                        request.resource.data.keys().hasAll([
                          'type', 'name', 'email', 'phone', 'address', 'country',
                          'preferredContactMethod', 'industry', 'additionalDetails', 'source',
                          'active', 'createdAt', 'updatedAt', 'creatorId'
                        ]) &&
                        request.resource.data.keys().hasOnly([
                          'type', 'name', 'email', 'phone', 'address', 'country',
                          'preferredContactMethod', 'industry', 'additionalDetails', 'source',
                          'active', 'createdAt', 'updatedAt', 'creatorId'
                        ]) &&
                        request.resource.data.createdAt is timestamp &&
                        request.resource.data.updatedAt is timestamp &&
                        request.resource.data.type is string && request.resource.data.type in ['Individual', 'Business'] &&
                        request.resource.data.name is string &&
                        request.resource.data.email is string &&
                        request.resource.data.phone is string &&
                        request.resource.data.address is string &&
                        request.resource.data.country is string &&
                        request.resource.data.preferredContactMethod is string && request.resource.data.preferredContactMethod in ['Email', 'Phone', 'SMS'] &&
                        request.resource.data.industry is string && request.resource.data.industry in ['Technology', 'Healthcare', 'Finance', 'Retail', 'Education', 'Other'] &&
                        request.resource.data.additionalDetails is string &&
                        request.resource.data.source is string && request.resource.data.source in ['Website', 'Referral', 'Advertisement', 'Social Media', 'Event', 'Other'] &&
                        request.resource.data.active is bool;
      allow update: if is_authenticated() && (is_customer_owner() || is_admin()) &&
                        request.resource.data.creatorId == resource.data.creatorId &&
                        request.resource.data.updatedAt is timestamp;
      allow delete: if is_authenticated() && (is_customer_owner() || is_admin());
    }

    // --- 3. Rules for 'opportunities' collection: ---
    match /opportunities/{opportunityId} {
      function is_opportunity_owner() {
        return resource.data.creatorId == request.auth.uid;
      }
      allow read: if is_authenticated() && (is_opportunity_owner() || is_admin());
      allow create: if is_authenticated() &&
                        request.auth.uid == request.resource.data.creatorId &&
                        request.resource.data.keys().hasAll([
                          'name', 'customerId', 'customerName', 'currency', 'priceBookId', 'expectedStartDate',
                          'expectedCloseDate', 'salesStage', 'probability', 'value', 'notes',
                          'createdAt', 'updatedAt', 'creatorId'
                        ]) &&
                        request.resource.data.keys().hasOnly([
                          'name', 'customerId', 'customerName', 'currency', 'priceBookId', 'expectedStartDate',
                          'expectedCloseDate', 'salesStage', 'probability', 'value', 'notes',
                          'createdAt', 'updatedAt', 'creatorId'
                        ]) &&
                        request.resource.data.createdAt is timestamp &&
                        request.resource.data.updatedAt is timestamp &&
                        request.resource.data.name is string &&
                        request.resource.data.customerId is string &&
                        request.resource.data.customerName is string &&
                        request.resource.data.currency is string &&
                        request.resource.data.priceBookId is string &&
                        (isValidTimestampObject(request.resource.data.expectedStartDate) || request.resource.data.expectedStartDate == null) &&
                        (isValidTimestampObject(request.resource.data.expectedCloseDate) || request.resource.data.expectedCloseDate == null) &&
                        request.resource.data.salesStage is string && request.resource.data.salesStage in ['Prospect', 'Qualification', 'Proposal', 'Negotiation', 'Won', 'Lost'] &&
                        request.resource.data.probability is int && request.resource.data.probability >= 0 && request.resource.data.probability <= 100 &&
                        request.resource.data.value is number && request.resource.data.value >= 0 &&
                        request.resource.data.notes is string;
      allow update: if is_authenticated() && (is_opportunity_owner() || is_admin()) &&
                        request.resource.data.creatorId == resource.data.creatorId &&
                        request.resource.data.updatedAt is timestamp;
      allow delete: if is_authenticated() && (is_opportunity_owner() || is_admin());
    }

    // --- 4. Rules for sub-collections of 'opportunities' ---
    match /opportunities/{opportunityId}/{subcollection=**} {
      allow read, create, update, delete: if is_authenticated() &&
                                          (get(/databases/$(database)/documents/opportunities/$(opportunityId)).data.creatorId == request.auth.uid || is_admin());
    }

    // --- 5. Rules for App Metadata Collections (Settings, Countries, Currencies, Price Books): ---

    // Global settings for the app (single document)
    match /settings/{documentId} {
      allow read: if is_authenticated();
      allow write: if is_admin();
    }

    // Countries data (for dropdowns)
    match /countries/{documentId} {
      allow read: if is_authenticated();
      allow write: if is_admin();
    }

    // Currency data (for dropdowns)
    match /currencies/{documentId} {
      allow read: if is_authenticated();
      allow create, update, delete: if is_admin();
    }

    // Price Book data (for dropdowns) - UPDATED FOR NEW FIELDS AND UNIQUENESS
    // Rules for the actual priceBook documents. Uniqueness is enforced via priceBookNameCurrencyIndexes.
    match /priceBooks/{documentId} {
      allow read: if is_authenticated();
      
      // Create: Admin only, with validation and uniqueness check.
      allow create: if is_admin() &&
                        request.resource.data.keys().hasAll([
                          'name', 'normalizedName', 'description', 'currency', 'normalizedCurrency', 'isActive', 'validFrom'
                        ]) &&
                        request.resource.data.name is string &&
                        request.resource.data.normalizedName is string && // New validation for normalizedName
                        request.resource.data.description is string &&
                        request.resource.data.currency is string &&
                        request.resource.data.normalizedCurrency is string && // New validation for normalizedCurrency
                        request.resource.data.isActive is bool &&
                        (isValidTimestampObject(request.resource.data.validFrom) || request.resource.data.validFrom == null) &&
                        (isValidTimestampObject(request.resource.data.validTo) || request.resource.data.validTo == null) &&
                        // Ensure normalizedName and normalizedCurrency are lowercase and contain no whitespace
                        request.resource.data.normalizedName == request.resource.data.normalizedName.lower() &&
                        !request.resource.data.normalizedName.matches('.*\\s.*') && // Ensure no whitespace
                        request.resource.data.normalizedCurrency == request.resource.data.normalizedCurrency.lower() &&
                        !request.resource.data.normalizedCurrency.matches('.*\\s.*') && // Ensure no whitespace
                        // Ensure no index with this normalized name_currency combo already exists
                        !exists(/databases/$(database)/documents/priceBookNameCurrencyIndexes/$(getPriceBookIndexId(request.resource.data.normalizedName, request.resource.data.normalizedCurrency)));

      // Update: Admin only, with validation.
      allow update: if is_admin() &&
                        request.resource.data.name is string &&
                        request.resource.data.normalizedName is string && // Validate normalizedName on update
                        request.resource.data.description is string &&
                        request.resource.data.currency is string &&
                        request.resource.data.normalizedCurrency is string && // Validate normalizedCurrency on update
                        request.resource.data.isActive is bool &&
                        (isValidTimestampObject(request.resource.data.validFrom) || request.resource.data.validFrom == null) &&
                        (isValidTimestampObject(request.resource.data.validTo) || request.resource.data.validTo == null) &&
                        // Ensure normalizedName and normalizedCurrency are lowercase and contain no whitespace
                        request.resource.data.normalizedName == request.resource.data.normalizedName.lower() &&
                        !request.resource.data.normalizedName.matches('.*\\s.*') && // Ensure no whitespace
                        request.resource.data.normalizedCurrency == request.resource.data.normalizedCurrency.lower() &&
                        !request.resource.data.normalizedCurrency.matches('.*\\s.*'); // Ensure no whitespace
      
      allow delete: if is_admin();
    }

    // --- NEW COLLECTION: priceBookNameCurrencyIndexes ---
    // This collection stores unique combinations of name+currency as document IDs
    // to enforce uniqueness across the 'priceBooks' collection via security rules.
    match /priceBookNameCurrencyIndexes/{indexId} {
      // Only Admins can write to this index collection.
      // The indexId must match the expected format (normalizedName_normalizedCurrency).
      // The data must contain the actual priceBookId, normalizedName, and normalizedCurrency.

      // Create: Allows creation of a new index, but only if it doesn't already exist.
      allow create: if is_admin() &&
                        request.resource.id == getPriceBookIndexId(request.resource.data.priceBookName, request.resource.data.priceBookCurrency) &&
                        request.resource.data.priceBookId is string &&
                        request.resource.data.priceBookName is string && // This is the normalized name for the index
                        request.resource.data.priceBookCurrency is string && // This is the normalized currency for the index
                        // Ensure the stored normalized values are actually normalized
                        request.resource.data.priceBookName == request.resource.data.priceBookName.lower() &&
                        !request.resource.data.priceBookName.matches('.*\\s.*') &&
                        request.resource.data.priceBookCurrency == request.resource.data.priceBookCurrency.lower() &&
                        !request.resource.data.priceBookCurrency.matches('.*\\s.*') &&
                        // Ensure this index ID does not exist BEFORE the write.
                        !exists(request.resource.__path__);
      
      // Update: Only Admins can update.
      allow update: if is_admin() &&
                        request.resource.id == getPriceBookIndexId(request.resource.data.priceBookName, request.resource.data.priceBookCurrency) &&
                        request.resource.data.priceBookId is string &&
                        request.resource.data.priceBookName is string &&
                        request.resource.data.priceBookCurrency is string &&
                        // Ensure the stored normalized values are actually normalized
                        request.resource.data.priceBookName == request.resource.data.priceBookName.lower() &&
                        !request.resource.data.priceBookName.matches('.*\\s.*') &&
                        request.resource.data.priceBookCurrency == request.resource.data.priceBookCurrency.lower() &&
                        !request.resource.data.priceBookCurrency.matches('.*\\s.*') &&
                        // Ensure the priceBookId for this index document doesn't change
                        resource.data.priceBookId == request.resource.data.priceBookId;

      // Delete: Only Admins can delete index entries.
      allow delete: if is_admin();
      
      // No one can read this collection directly (it's purely for indexing)
      allow read: if false;
    }
  }
}
